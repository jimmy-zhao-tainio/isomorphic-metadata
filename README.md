# isomorphic-metadata

`isomorphic-metadata` is a deterministic metadata backend. The canonical representation is an XML workspace on disk (git-friendly), but you can round-trip: import from SQL, generate SQL/C#/SSDT, and load/save model instances via generated C# APIs for tooling.

This repo ships two CLI tools:

`meta` (Meta CLI): workspace/model/instance operations, diff/merge, import, generate.  
`meta-schema` (MetaSchema CLI): schema extraction and sanctioned catalogs (for example `TypeConversionCatalog`).

## Metadata foundations (project terminology)

In this project, metadata is not "extra comments about data". Metadata is the product model itself:

- `metadata/model.xml`: the schema contract (entities, scalar properties, required relationships).
- `metadata/instance/*.xml`: the instance graph for that model (rows + relationship usages).
- `metadata/workspace.xml`: workspace-level configuration for layout/encoding/order and storage.

Core terms:

- `Model`: named set of entity definitions.
- `Entity`: a record type (similar to a table).
- `Property`: scalar attribute on an entity instance.
- `Relationship`: required reference from one entity to another.
- `Instance`: one row/record of an entity, identified by `Id`.
- `Workspace`: on-disk unit that contains model + instance + workspace config.

### Why we need metadata

For BI/data-platform teams, semantics change constantly (new systems, new mappings, new rules). If semantics are hardcoded in application code only, change velocity and reviewability collapse.

Metadata gives you:

- explicit schema/instance contracts you can inspect and validate.
- deterministic refactors (model + instance rewritten together).
- generation targets (SQL/C#/SSDT) from one authoritative model.
- repeatable onboarding: team members can inspect the model and instance graph directly.

### Why isomorphic metadata

Isomorphic means the **same semantics** can live in multiple forms without translation drift.

Think of it as one model with three "native surfaces", each optimized for a different kind of work:

- **XML workspace**: canonical, deterministic, and **git-first** (clean diffs, reviewable history, mergeable refactors).
- **SQL**: **data-first** and database-native (easy to inspect/query/validate at scale; good interchange format when your source of truth starts in a database).
- **C#**: **application-first** (strongly typed objects for tools and apps; no XML parsing in consumer code; easy to integrate into pipelines/services).

Because the semantics are the same, multiple producers and consumers can collaborate without rewriting the model for each layer:

- analysts/modelers edit model + instance in workspace form,
- platform engineers generate SQL/SSDT,
- application/tooling engineers consume the generated C# API.

### Why git matters for metadata

The workspace is designed for version control:

- deterministic writer output (stable ordering, utf-8 no bom, LF) keeps diffs clean.
- model and instance changes are code-reviewed like source code.
- branch/merge workflows apply to metadata evolution.
- refactors are auditable through before/after XML deltas.

## Workspace contract

A workspace is a directory containing:

`metadata/workspace.xml`  
`metadata/model.xml`  
`metadata/instance/...`

Instance data may be sharded: multiple instance files can contain rows for the same entity; load merges those shards and save preserves existing shard file layout (new rows for an entity are written to that entity's primary shard).

## Meta CLI at a glance

`meta` operates on workspaces and provides these capability groups:

Workspace operations: create and inspect workspaces (`init`, `status`).  
Validation and inspection: check integrity and explore model/instance (`check`, `list`, `view`, `query`, `graph`).  
Edits: mutate models and instance data (`model ...`, `insert`, `delete`, `bulk-insert`, `instance update`, `instance relationship set|list`, `instance diff`, `instance merge`).  
Model analysis and guided refactor: read-only relationship inference (`model suggest`) and atomic promotion command (`model refactor property-to-relationship`).  
Pipelines: import and generate (`import ...`, `generate ...`).

## One sample across XML, SQL, and C#

### XML model (`metadata/model.xml`)

```xml
<?xml version="1.0" encoding="utf-8"?>
<Model name="EnterpriseBIPlatform">
  <Entities>
    <Entity name="Cube" plural="Cubes">
      <Properties>
        <Property name="CubeName" />
        <Property name="Purpose" isRequired="false" />
        <Property name="RefreshMode" isRequired="false" />
      </Properties>
    </Entity>

    <Entity name="Measure" plural="Measures">
      <Properties>
        <Property name="MeasureName" />
        <Property name="MDX" isRequired="false" />
      </Properties>
      <Relationships>
        <Relationship entity="Cube" />
      </Relationships>
    </Entity>

    <Entity name="SystemType" plural="SystemTypes">
      <Properties>
        <Property name="TypeName" />
      </Properties>
    </Entity>

    <Entity name="System" plural="Systems">
      <Properties>
        <Property name="SystemName" />
        <Property name="Version" isRequired="false" />
      </Properties>
      <Relationships>
        <Relationship entity="SystemType" />
      </Relationships>
    </Entity>

    <Entity name="SystemCube" plural="SystemCubes">
      <Properties>
        <Property name="ProcessingMode" isRequired="false" />
      </Properties>
      <Relationships>
        <Relationship entity="Cube" />
        <Relationship entity="System" />
      </Relationships>
    </Entity>
  </Entities>
</Model>
```

### XML instance (`metadata/instance/*.xml`)

```xml
<?xml version="1.0" encoding="utf-8"?>
<EnterpriseBIPlatform>
  <Cubes>
    <Cube Id="1">
      <CubeName>Sales Performance</CubeName>
      <Purpose>Monthly revenue and margin tracking.</Purpose>
      <RefreshMode>Scheduled</RefreshMode>
    </Cube>
  </Cubes>

  <Measures>
    <Measure Id="1" CubeId="1">
      <MeasureName>Sales Amount</MeasureName>
      <MDX>[Measures].[Sales Amount]</MDX>
    </Measure>
  </Measures>

  <SystemTypes>
    <SystemType Id="1">
      <TypeName>Internal</TypeName>
    </SystemType>
  </SystemTypes>

  <Systems>
    <System Id="1" SystemTypeId="1">
      <SystemName>Enterprise Analytics Platform</SystemName>
      <Version>2.1</Version>
    </System>
  </Systems>

  <SystemCubes>
    <SystemCube Id="1" CubeId="1" SystemId="1">
      <ProcessingMode>InMemory</ProcessingMode>
    </SystemCube>
  </SystemCubes>
</EnterpriseBIPlatform>
```

### Generated SQL (`meta generate sql`)

`meta generate sql` writes `schema.sql` and `data.sql` (deterministic DDL and INSERT scripts).

```sql
CREATE TABLE [dbo].[Cube] (
  [Id] INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
  [CubeName] NVARCHAR(256) NOT NULL,
  [Purpose] NVARCHAR(256) NULL,
  [RefreshMode] NVARCHAR(256) NULL
);

CREATE TABLE [dbo].[Measure] (
  [Id] INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
  [MeasureName] NVARCHAR(256) NOT NULL,
  [MDX] NVARCHAR(256) NULL,
  [CubeId] INT NOT NULL
);

CREATE TABLE [dbo].[SystemType] (
  [Id] INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
  [TypeName] NVARCHAR(256) NOT NULL
);

CREATE TABLE [dbo].[System] (
  [Id] INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
  [SystemName] NVARCHAR(256) NOT NULL,
  [Version] NVARCHAR(256) NULL,
  [SystemTypeId] INT NOT NULL
);

CREATE TABLE [dbo].[SystemCube] (
  [Id] INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
  [ProcessingMode] NVARCHAR(256) NULL,
  [CubeId] INT NOT NULL,
  [SystemId] INT NOT NULL
);

ALTER TABLE [dbo].[Measure]
ADD CONSTRAINT [FK_Measure_Cube_CubeId]
FOREIGN KEY ([CubeId]) REFERENCES [dbo].[Cube]([Id]);

ALTER TABLE [dbo].[System]
ADD CONSTRAINT [FK_System_SystemType_SystemTypeId]
FOREIGN KEY ([SystemTypeId]) REFERENCES [dbo].[SystemType]([Id]);

ALTER TABLE [dbo].[SystemCube]
ADD CONSTRAINT [FK_SystemCube_Cube_CubeId]
FOREIGN KEY ([CubeId]) REFERENCES [dbo].[Cube]([Id]);

ALTER TABLE [dbo].[SystemCube]
ADD CONSTRAINT [FK_SystemCube_System_SystemId]
FOREIGN KEY ([SystemId]) REFERENCES [dbo].[System]([Id]);
```

### Generated C# (`meta generate csharp`)

#### What gets generated

`meta generate csharp` emits dependency-free consumer types in `GeneratedMetadata`:
- `<ModelName>.cs` (static model facade / container, e.g. `EnterpriseBIPlatform`)
- `<Entity>.cs` (one file per entity, POCOs)

#### Consumer usage (dependency-free)

```csharp
using GeneratedMetadata;
using System;
using System.Linq;

// Consumer view: dependency-free POCOs + a strongly-typed model facade.
foreach (var system in EnterpriseBIPlatform.Systems)
{
    Console.WriteLine($"{system.SystemName} [{system.SystemType.TypeName}]");

    foreach (var link in EnterpriseBIPlatform.SystemCubes.Where(x => x.SystemId == system.Id))
    {
        Console.WriteLine($"  Cube: {link.Cube.CubeName} (mode: {link.ProcessingMode ?? "n/a" })");
    }
}

foreach (var measure in EnterpriseBIPlatform.Measures)
{
    Console.WriteLine($"{measure.Cube.CubeName}.{measure.MeasureName}");
}
```

#### Optional tooling surface (`--tooling`)

If you also run `meta generate csharp --tooling`, the generator emits `<ModelName>.Tooling.cs` with workspace load/save helpers backed by Meta runtime services. Keep this separate from dependency-free consumer usage.

## Install and run

Build:

```powershell
dotnet build Metadata.Framework.sln
```

Run directly:

```powershell
dotnet run --project Meta.Cli/Meta.Cli.csproj -- help
```

Or use the executable in repo root:

```powershell
.\meta.exe help
```

Optional PowerShell profile install (so `meta ...` works without `./`):

```powershell
powershell -ExecutionPolicy Bypass -File .\install-meta.ps1
```

## XML contracts summary

### Model XML

`metadata/model.xml` defines the schema for your metadata workspace: which entities exist, what properties they have, and how entities relate to each other.

A model has one root `<Model name="...">` and then:

- `<Entity>` defines a record type (like a table).
- `name="Cube"` is the singular name.
- `plural="Cubes"` controls how instances are grouped in instance XML (and exposed in generated APIs). If omitted, plural defaults to `<EntityName>s`.
- `<Properties>` lists scalar fields for the entity. `dataType="string"` is the default and omitted; properties are required by default (`isRequired="true"`), and optional fields use `isRequired="false"`.
- `<Relationships>` lists required foreign-key style references to other entities. A relationship points to a target entity and is required by default. In instance XML it becomes `${TargetEntity}Id` by default. If you need multiple relationships to the same target, specify `role="..."` and it becomes `${Role}Id`.
- `Id` is implicit on every entity, so `Property name="Id"` is not written.

Example:

```xml
<Model name="EnterpriseBIPlatform">
  <Entities>
    <Entity name="Measure" plural="Measures">
      <Properties>
        <Property name="MeasureName" />
      </Properties>
      <Relationships>
        <Relationship entity="Cube" />
        <Relationship entity="Cube" role="SourceCube" />
      </Relationships>
    </Entity>
  </Entities>
</Model>
```

### Instance XML

`metadata/instance/*.xml` stores the data for a model.

The root element is the model name (for example `<EnterpriseBIPlatform>`).

Each entity's instances are grouped under a plural container element (for example `<Cubes>`, `<Measures>`). Inside the container, each record is written as the singular entity element (for example `<Cube ...>`, `<Measure ...>`).

Every record must have an `Id="..."` attribute.

Relationships are stored as `...Id` attributes on the record. By default a relationship to `Cube` is stored as `CubeId="..."`. If the relationship has a role like `role="SourceCube"`, it is stored as `SourceCubeId="..."`.

Scalar properties are written as child elements. Missing element means unset. An empty element means explicit empty string.

Example:

```xml
<Measures>
  <Measure Id="1" CubeId="10" SourceCubeId="11">
    <MeasureName>Sales Amount</MeasureName>
    <Notes />
  </Measure>
</Measures>
```

## Meta command guide (exhaustive)

Workspace discovery defaults to the current directory (searching upward). Use `--workspace <path>` to override.

Global behavior:

- success responses use `OK: ...`.
- validation/usage/runtime failures use `Error: ...` and non-zero exit.
- `--strict` upgrades warnings to errors for mutating commands.

### Command discovery

| Command | What it is for | Example |
|---|---|---|
| `meta help` | Show top-level command groups and examples. | `meta help` |
| `meta <command> help` | Show usage/options/examples for one command. | `meta model help` |
| `meta <command> <subcommand> --help` | Show detailed subcommand help. | `meta model suggest --help` |

### Workspace commands

| Command | What it is for | Example |
|---|---|---|
| `meta init [<path>]` | Create a new workspace at target path (or current directory). | `meta init Samples\\DemoWorkspace` |
| `meta status` | Print workspace summary (entities, rows, basic counts). | `meta status` |

### Inspect and validate

| Command | What it is for | Example |
|---|---|---|
| `meta check` | Run model+instance integrity checks. | `meta check` |
| `meta list entities` | List entities and high-level counts. | `meta list entities` |
| `meta list properties <Entity>` | List scalar properties for one entity. | `meta list properties Cube` |
| `meta list relationships <Entity>` | List declared outgoing relationships for one entity. | `meta list relationships Measure` |
| `meta view entity <Entity>` | Show one entity schema card. | `meta view entity Cube` |
| `meta view instance <Entity> <Id>` | Show one instance field/value view. | `meta view instance Cube 1` |
| `meta query <Entity> ...` | Search instances with `--equals` / `--contains` filters. | `meta query Cube --contains CubeName Sales --top 20` |
| `meta graph stats` | Print graph metrics, top degrees, cycle samples. | `meta graph stats --top 10 --cycles 5` |
| `meta graph inbound <Entity>` | Show who references the target entity. | `meta graph inbound Cube --top 20` |

### Model commands

| Command | What it is for | Example |
|---|---|---|
| `meta model suggest` | Read-only key/reference inference (eligible relationship suggestions by default). | `meta model suggest` |
| `meta model suggest --print-commands` | Print copy/paste refactor commands for eligible suggestions. | `meta model suggest --print-commands` |
| `meta model suggest --show-keys --explain` | Include candidate key diagnostics and explain blocks. | `meta model suggest --show-keys --explain` |
| `meta model suggest --show-blocked --explain` | Include blocked relationship candidates and blockers. | `meta model suggest --show-blocked --explain` |
| `meta model refactor property-to-relationship ...` | Atomic model+instance rewrite from scalar property to required relationship. | `meta model refactor property-to-relationship --source Order.WarehouseCode --target Warehouse --lookup WarehouseCode --drop-source-property` |
| `meta model add-entity <Name>` | Add a new entity definition. | `meta model add-entity SourceSystem` |
| `meta model rename-entity <Old> <New>` | Rename an entity definition. | `meta model rename-entity SourceSystem Source` |
| `meta model drop-entity <Entity>` | Drop entity definition (blocked if instances or inbound refs exist). | `meta model drop-entity SourceSystem` |
| `meta model add-property <Entity> <Property> ...` | Add scalar property; uses `--default-value` to backfill required additions on existing rows. | `meta model add-property Cube Purpose --required true --default-value Unknown` |
| `meta model rename-property <Entity> <Old> <New>` | Rename one scalar property. | `meta model rename-property Cube Purpose BusinessPurpose` |
| `meta model drop-property <Entity> <Property>` | Remove one scalar property. | `meta model drop-property Cube Description` |
| `meta model add-relationship <From> <To> ...` | Add required relationship; uses `--default-id` for backfill when source has rows. | `meta model add-relationship Measure Cube --default-id 1` |
| `meta model drop-relationship <From> <To>` | Remove declared relationship from model. | `meta model drop-relationship Measure Cube` |

### Instance commands

| Command | What it is for | Example |
|---|---|---|
| `meta insert <Entity> <Id> --set ...` | Insert one row with explicit Id. | `meta insert Cube 10 --set "CubeName=Ops Cube"` |
| `meta insert <Entity> --auto-id --set ...` | Insert one row with generated numeric Id. | `meta insert Cube --auto-id --set "CubeName=Auto Cube"` |
| `meta bulk-insert <Entity> ...` | Insert many rows from tsv/csv file or stdin. | `meta bulk-insert Cube --from tsv --file .\\cube.tsv --key Id` |
| `meta instance update <Entity> <Id> --set ...` | Update fields on one row by Id. | `meta instance update Cube 10 --set "Purpose=Operations reporting"` |
| `meta instance relationship set <FromEntity> <FromId> --to <ToEntity> <ToId>` | Set exact-one relationship usage to target row. | `meta instance relationship set Measure 1 --to Cube 10` |
| `meta instance relationship list <FromEntity> <FromId>` | List relationship usages for one row. | `meta instance relationship list Measure 1` |
| `meta delete <Entity> <Id>` | Delete one row by Id. | `meta delete Cube 10` |

### Instance diff and merge (quick index)

| Command | What it is for | Example |
|---|---|---|
| `meta instance diff <left> <right>` | Diff two workspaces with byte-identical `model.xml`. | `meta instance diff .\\LeftWorkspace .\\RightWorkspace` |
| `meta instance merge <target> <diffWorkspace>` | Apply equal-model diff artifact to target workspace. | `meta instance merge .\\TargetWorkspace .\\RightWorkspace.instance-diff` |
| `meta instance diff-aligned <left> <right> <alignment>` | Diff two workspaces using explicit alignment mappings. | `meta instance diff-aligned .\\LeftWorkspace .\\RightWorkspace .\\AlignmentWorkspace` |
| `meta instance merge-aligned <target> <diffWorkspace>` | Apply aligned diff artifact to target workspace. | `meta instance merge-aligned .\\TargetWorkspace .\\RightWorkspace.instance-diff-aligned` |

### Import and generate

| Command | What it is for | Example |
|---|---|---|
| `meta import xml <modelXml> <instanceXml> --new-workspace <path>` | Create new workspace from XML model+instance files. | `meta import xml .\\Samples\\SampleModel.xml .\\Samples\\SampleInstance.xml --new-workspace .\\Samples\\ImportedXml` |
| `meta import sql <connectionString> <schema> --new-workspace <path>` | Create new workspace by importing SQL metadata. | `meta import sql "Server=.;Database=EnterpriseBIPlatform;Trusted_Connection=True;TrustServerCertificate=True;" dbo --new-workspace .\\Samples\\ImportedSql` |
| `meta import csv <csvFile> --entity <EntityName> (--new-workspace <path> or --workspace <path>)` | Landing import: one CSV to one entity + rows in new or existing workspace. | `meta import csv .\\Samples\\landing.csv --entity Landing --new-workspace .\\Samples\\ImportedCsv` |
| `meta generate sql --out <dir>` | Generate deterministic SQL schema + data scripts. | `meta generate sql --out .\\out\\sql` |
| `meta generate csharp --out <dir>` | Generate dependency-free consumer C# API. | `meta generate csharp --out .\\out\\csharp` |
| `meta generate csharp --out <dir> --tooling` | Generate optional tooling helpers for load/save/import flows. | `meta generate csharp --out .\\out\\csharp --tooling` |
| `meta generate ssdt --out <dir>` | Generate SSDT project artifacts. | `meta generate ssdt --out .\\out\\ssdt` |

### Full example: CSV import -> suggest -> refactor

This is the intended landing workflow: import flat CSVs, run suggest, then apply an atomic model+instance refactor.

`meta model suggest` is structural and deterministic. It scans model+instance data and only prints eligible relationship promotions by default.

Eligible means the promotion satisfies 100% referential integrity (RI) before any mutation:
- target lookup property is complete and unambiguous (no null/blank values, no duplicates)
- source property is complete (no null/blank values)
- every source value resolves to an existing target lookup value (full coverage, no unmatched values)
- source and target scalar types are compatible under strict rules (no implicit casting)

If any rule fails, the item is not printed as a default suggestion.

```cmd
cd /d C:\Users\jimmy\Desktop\Metadata
rmdir /s /q C:\Users\jimmy\Desktop\Metadata\Samples\SuggestDemo\Workspace

meta import csv C:\Users\jimmy\Desktop\Metadata\Samples\SuggestDemo\demo-csv\products.csv --entity Product --new-workspace C:\Users\jimmy\Desktop\Metadata\Samples\SuggestDemo\Workspace
cd /d C:\Users\jimmy\Desktop\Metadata\Samples\SuggestDemo\Workspace
meta import csv ..\demo-csv\suppliers.csv --entity Supplier
meta import csv ..\demo-csv\categories.csv --entity Category
meta import csv ..\demo-csv\warehouses.csv --entity Warehouse
meta import csv ..\demo-csv\orders.csv --entity Order

meta model suggest
meta model suggest --print-commands

meta model refactor property-to-relationship --source Order.ProductCode --target Product --lookup ProductCode --drop-source-property
meta model refactor property-to-relationship --source Order.SupplierCode --target Supplier --lookup SupplierCode --drop-source-property
meta model refactor property-to-relationship --source Order.WarehouseCode --target Warehouse --lookup WarehouseCode --drop-source-property

meta model suggest
meta check
```

`meta model suggest` output before refactor:

```text
OK: model suggest
Workspace: C:\Users\jimmy\Desktop\Metadata\Samples\SuggestDemo\Workspace
Model: ProductModel
Suggestions: 3

Relationship suggestions
  1) Order.ProductCode -> Product (lookup: Product.ProductCode)
  2) Order.SupplierCode -> Supplier (lookup: Supplier.SupplierCode)
  3) Order.WarehouseCode -> Warehouse (lookup: Warehouse.WarehouseCode)
```

`meta model suggest` output after all three refactors:

```text
OK: model suggest
Workspace: C:\Users\jimmy\Desktop\Metadata\Samples\SuggestDemo\Workspace
Model: ProductModel
Suggestions: 0

Relationship suggestions
  (none)
```

Model change example (`metadata/model.xml`) for `Order`:

Before (after CSV import, before refactor):

```xml
<Entity name="Order">
  <Properties>
    <Property name="OrderNumber" />
    <Property name="ProductCode" />
    <Property name="SupplierCode" />
    <Property name="WarehouseCode" />
    <Property name="StatusText" />
  </Properties>
</Entity>
```

After running all three `property-to-relationship` refactors (`ProductCode`, `SupplierCode`, `WarehouseCode`):

```xml
<Entity name="Order">
  <Properties>
    <Property name="OrderNumber" />
    <Property name="StatusText" />
  </Properties>
  <Relationships>
    <Relationship entity="Product" />
    <Relationship entity="Supplier" />
    <Relationship entity="Warehouse" />
  </Relationships>
</Entity>
```

These promotions rewrite each `Order` row from scalar `ProductCode`/`SupplierCode`/`WarehouseCode` values to required relationship usages `ProductId`/`SupplierId`/`WarehouseId`, then remove the source scalar properties when `--drop-source-property` is used.

Instance diff/merge can be used to propagate these changes across workspaces (see **Instance diff and merge**).

### Instance diff and merge

#### 1. Purpose

Workspaces evolve independently on different branches. `meta instance diff` and `meta instance merge` are deterministic synchronization primitives for instance data:

- `diff` produces a structured change artifact from Left -> Right.
- `merge` applies that artifact to a target workspace with strict validation.

This is not a text diff. It is a semantic diff over entity rows, scalar values, and relationship usages.

#### 2. What `meta instance diff` does (mechanics)

Inputs:

- Left workspace
- Right workspace

Output:

- a deterministic diff workspace artifact (default sibling path: `<RightWorkspace>.instance-diff`)

Mechanics:

- requires byte-identical `metadata/model.xml` for equal-model diff.
- compares row identity by entity + `Id`.
- compares scalar property values.
- compares relationship usage values (`...Id` attributes).
- compares row presence/absence.

Conceptual change classes captured by the artifact:

- added rows (present in Right, absent in Left)
- removed rows (present in Left, absent in Right)
- updated scalar values on shared rows
- updated relationship references on shared rows

Determinism guarantees:

- canonical ordering/normalization is applied before writing the diff artifact.
- entity/property traversal and row comparisons are stable.
- same inputs produce the same logical diff artifact.

The artifact is a structured description of how to transform Left into Right.

#### 3. What `meta instance merge` does (mechanics)

Inputs:

- target workspace
- diff artifact workspace (from `meta instance diff`)

Operation:

- verifies precondition: target must match the diff Left snapshot.
- applies the diff Right snapshot to the target in memory.
- normalizes and validates the resulting workspace.
- persists once only if validation/postconditions pass.

Atomicity and safety:

- all changes are applied or none are persisted.
- any failure restores pre-merge in-memory state and aborts.
- save is a single workspace write operation after successful validation.

Determinism:

- same target + same diff artifact -> same resulting workspace state.

#### 4. Referential integrity behavior

Merge is strict. It fails rather than writing invalid state.

- required relationship usage missing -> validation failure.
- relationship target row missing -> validation failure.
- deleting rows that remain referenced -> validation failure.
- relationship updates are applied as part of the snapshot and validated with the whole workspace.

Operation ordering is snapshot-based: merge builds the target end state in memory, validates, then saves. It does not persist partial intermediate steps.

#### 5. Row identity model

Rows are matched by identity (`Entity`, `Id`), not by value similarity.

- identity stability is assumed.
- no fuzzy matching.
- no business-key reconciliation.

#### 6. Typical workflow

Example flow with two independently evolved workspaces:

1. baseline/integration workspace is your Left reference.
2. feature workspace with intended changes is your Right reference.
3. generate diff from Left -> Right.
4. apply diff into integration target (which must still match Left snapshot).

```powershell
meta instance diff .\WorkspaceA .\WorkspaceB
meta instance merge .\WorkspaceA .\WorkspaceB.instance-diff
```

If merge precondition fails, regenerate diff against the current target baseline.

#### 7. Interaction with model refactoring

`model refactor property-to-relationship` changes instance structure (scalar values moved to required relationship usages). Diff/merge captures and replays those instance-level structural value changes when both sides share the same model contract.

For model-contract drift between workspaces, use the aligned diff/merge path (`instance diff-aligned` / `instance merge-aligned`) with explicit alignment mappings.

#### 8. What this is NOT

- not a text merge tool.
- not automatic conflict resolution.
- not model/schema merge.
- not record matching by business key.
- not best-effort partial reconciliation.

#### 9. Command reference

```powershell
meta instance diff <LeftWs> <RightWs>
meta instance merge <TargetWs> <DiffWorkspace>
```

## MetaSchema

MetaSchema is the separate schema/canonical-catalog toolchain.

It handles schema extraction and sanctioned catalogs that `meta` can treat as metadata workspaces.

Sanctioned model references are kept as XML on disk and loaded by core runtime code:
- `Meta.Core/WorkspaceConfig/Models/MetaWorkspace.model.xml`
- `MetaSchema.Core/Models/SchemaCatalog.model.xml`
- `MetaSchema.Catalogs/TypeConversionCatalog/metadata/model.xml`

To regenerate sanctioned model C# APIs through the same public CLI surface, run:

```powershell
powershell -ExecutionPolicy Bypass -File .\scripts\Generate-SanctionedModelApis.ps1
```

This script uses `meta generate csharp --tooling` for each sanctioned model.

Current status: `meta-schema extract sqlserver` is implemented as a scaffold and does not query SQL Server yet.

### TypeConversionCatalog

`TypeConversionCatalog` is a workspace that models a canonical type system (`Meta`) and mappings to/from platform type systems (SqlServer, Synapse, Snowflake, SSIS, CSharp). The model centers around TypeSystems/DataTypes, facets, and mapping rules.

Key entities include `TypeSystem`, `DataType`, `TypeSpec`, `TypeMapping`, `TypeMappingCondition`, `TypeMappingFacetTransform`, `Setting`, and `ConversionImplementation`.

#### Seeded conversion table excerpt: Meta -> SqlServer

| Meta type | SqlServer type | Lossiness | Implementation |
|---|---|---|---|
| AnsiString | varchar | Exact | Sql.Cast |
| AnsiStringFixedLength | char | Exact | Sql.Cast |
| Binary | varbinary | Exact | Sql.Cast |
| Boolean | bit | Exact | Sql.Identity |
| Date | date | Exact | Sql.Identity |
| DateTime2 | datetime2 | Exact | Sql.Cast |
| DateTimeOffset | datetimeoffset | Exact | Sql.Cast |
| Decimal | decimal | Exact | Sql.Cast |
| Guid | uniqueidentifier | Exact | Sql.Identity |
| Int32 | int | Exact | Sql.Identity |
| Int64 | bigint | Exact | Sql.Identity |
| Object | sql_variant | Lossy | Sql.Convert |
| String | nvarchar | Exact | Sql.Cast |
| StringFixedLength | nchar | Exact | Sql.Cast |
| Time | time | Exact | Sql.Cast |
| Xml | xml | Exact | Sql.Identity |

#### Seeded conversion table excerpt: SqlServer -> SSIS

| SqlServer type | SSIS type | Lossiness | Implementation |
|---|---|---|---|
| bigint | DT_I8 | Exact | Ssis.DataConversion |
| bit | DT_BOOL | Exact | Ssis.DataConversion |
| datetime2 | DT_DBTIMESTAMP2 | Exact | Ssis.DataConversion |
| datetimeoffset | DT_DBTIMESTAMPOFFSET | Exact | Ssis.DataConversion |
| decimal | DT_NUMERIC | Exact | Ssis.DataConversion |
| int | DT_I4 | Exact | Ssis.DataConversion |
| nvarchar | DT_WSTR | Exact | Ssis.DataConversion |
| smallint | DT_I2 | Exact | Ssis.DataConversion |
| time | DT_DBTIME2 | Exact | Ssis.DataConversion |
| tinyint | DT_UI1 | Exact | Ssis.DataConversion |
| uniqueidentifier | DT_GUID | Exact | Ssis.DataConversion |
| xml | DT_NTEXT | Lossy | Ssis.DataConversion |

#### Defaulting rules excerpt

Some platform-defaulting rules are encoded as mappings with conditions/transforms. (`Length=-1` means MAX.)

| Meta type | SqlServer type | When | Then |
|---|---|---|---|
| Decimal | decimal | Precision missing | Precision=18 |
| Decimal | decimal | Scale missing | Scale=0 |
| Time | time | TimePrecision missing | TimePrecision=7 |
| DateTime2 | datetime2 | TimePrecision missing | TimePrecision=7 |
| DateTimeOffset | datetimeoffset | TimePrecision missing | TimePrecision=7 |
| AnsiString | varchar | Length >= 8001 | Length=-1 |
| String | nvarchar | Length >= 4001 | Length=-1 |
| Binary | varbinary | Length >= 8001 | Length=-1 |

#### Commands

```powershell
meta-schema help
meta-schema extract sqlserver --help
meta-schema seed type-conversion --new-workspace .\MetaSchema.Catalogs\TypeConversionCatalog

meta check --workspace .\MetaSchema.Catalogs\TypeConversionCatalog
meta list entities --workspace .\MetaSchema.Catalogs\TypeConversionCatalog
meta query TypeMapping --contains Name Meta. --workspace .\MetaSchema.Catalogs\TypeConversionCatalog
```

## References

Full command surface and contracts: `COMMANDS.md`  
Transcript-style examples: `COMMANDS-EXAMPLES.md`

## Tests

```powershell
dotnet test Metadata.Framework.sln
```
